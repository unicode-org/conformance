/* Generate listformat test data with the following dimensions:

   1. locale
   2. type (conjunction, disjunction, unit)
   3. style (long, short, narrow)
*/

// Set up Node version to generate data specific to ICU/CLDR version
// e.g., `nvm install 21.6.0;nvm use 21.6.0` (ICU 74)

const common_fns = require("./common.js");
const gen_hash = require("./generate_test_hash.js");

const fs = require('node:fs');

let debug = false;

// Don't include "und" as a locale because the behavior depends on the platform.
const locales = [
  'en-US', 'zh-TW', 'es',
  'pt', 'vi', 'el', 'mt-MT', 'ru', 'en-GB',
  'bn', 'ar','mr', 'zu'];

const types = ['conjunction', 'disjunction', 'unit'];

const styles = ['long', 'short', 'narrow'];

const lists = [
  [],
  ['cat'],
  ['dog', 'cat'],
  ['fish', 'mouse', 'parakeet'],
  ['3 weeks', '2 days', '3 hours', '25 minutes']
];

const spanish_or_tests = [
  ['otros edificios', 'casas'],
  ['casas', 'otros edificios'],
];

const spanish_and_tests = [
  ['divertido', 'interesante'],
  ['interesante', 'divertido']
];


function generateAll() {

  let test_obj = {
    'Test scenario': 'list_fmt',
    'test_type': 'list_fmt',
    'description': 'list format test data generated by Node',
    'platformVersion': process.version,
    'icuVersion': process.versions.icu,
    'cldrVersion': process.versions.cldr
  };

  let test_cases = [];

  let verify_obj = {
    'test_type': 'list_fmt',
    'description': 'list format test data generated by Node',
    'platformVersion': process.version,
    'icuVersion': process.versions.icu,
    'cldrVersion': process.versions.cldr
  }
  let verify_cases = [];

  let label_num = 0;

  const expected_count = locales.length * types.length * styles.length *
        lists.length;

  console.log("Generating up to ", expected_count, " list_fmt tests for ",
              process.versions.icu);

  for (const locale of locales) {

    for (const type of types) {

      for (const style of styles) {

        // Create format object with these options
        let all_options = {
          'style': style,
          'list_type': type,  // Needed because "type" is a reserved word in Rust
          'type': type  // Backward compatible
        }

        let formatter;
        try {
          formatter = new Intl.ListFormat(locale, all_options);
        } catch (error) {
          console.log(error, ' with locale ',
                      locale, ' and options: ', all_options);
          continue;
        }

        let test_lists = lists;
        if (locale == 'es') {
          if (type == 'conjunction') {
            test_lists = spanish_and_tests;
          } else
          if (type == 'disjunction') {
            test_lists = spanish_or_tests;
          }
        } else {
          debug = false;
        }

        for (const list of test_lists) {
          try {
            result = formatter.format(list);
          } catch (error) {
            console.log('FORMATTER CREATION FAILS! ', error);
          }

          if (list.length < 2 && locale != 'en-US') {
            // We don't need all the cases for empty or single item lists;.
            continue;
          }

          const label_string = String(label_num);

          // TODO: Save this as a test case.
          let test_list;
          let test_case = {
            'input_list': list,
            'options': {...all_options}
          };
          gen_hash.generate_hash_for_test(test_case);
          test_case['label'] = label_string;

          if (locale != '') {
            test_case["locale"] = locale;
          }

          if (debug) {
            console.log("TEST CASE :", test_case);
          }
          test_cases.push(test_case);

          // Generate what we get.
          try{
            verify_cases.push({'label': label_string,
                               'verify': result});
            if (debug) {
              console.log('   expected = ', result);
            }
          } catch (error) {
            console.log('!!! error ', error, ' in label ', label_num,
                        ' for options ', options, ' and list ', list);
          }
          label_num ++;
        };
      }
    }
  }


  if (debug) {
    console.log('Number of list format tests generated for ',
                process.versions.icu, ': ', label_num);
    console.log(' RUN LIMIT = ', run_limit);
  }

  test_obj['tests'] = common_fns.sample_tests(test_cases, run_limit);
  try {
    fs.writeFileSync('list_fmt_test.json', JSON.stringify(test_obj, null, 2));
    // file written successfully
  } catch (err) {
    console.error(err);
  }

  verify_obj['verifications'] = common_fns.sample_tests(verify_cases, run_limit);
  try {
    fs.writeFileSync('list_fmt_verify.json', JSON.stringify(verify_obj, null, 2));
    // file written successfully
  } catch (err) {
    console.error(err);
  }
}

if (debug) {
  console.log('LIST FORMAT argv: ', process.argv);
}

let run_limit = -1;
if (process.argv.length >= 4) {
  if (process.argv[2] == '-run_limit') {
    run_limit = Number(process.argv[3]);
  }
}

/* Call the generator */
generateAll(run_limit);
