/* Generate segmenter test data with the following dimensions:

   1. locale
   2. type (conjunction, disjunction, unit)
   3. style (long, short, narrow)
*/

// Set up Node version to generate data specific to ICU/CLDR version
// e.g., `nvm install 21.6.0;nvm use 21.6.0` (ICU 74)

const common_fns = require("./common.js");
const gen_hash = require("./generate_test_hash.js");

const fs = require('node:fs');

let debug = false;

const test_type = "segmenter";

// TODO: set line to be same as word
const granularity = ['grapheme', 'word', 'sentence', 'line'];

// An incomplete list of things that should not be separated in line breaking.
// Mostly punctuation in combination with spaces.
// Note that this is not correct for Japanese, Chinese, or Korean
const line_values_to_merge_with_previous = [
  " ", ".", ",", ", ", "?", "? ", " ?", "!", "ã€‚", "", "á‹",
  ". ", ", ", "? ", "! ", "à¥¤", "à¥¤ ", "á‹ ",
  "â¹ ", "ØŸ", "â¹", "â€™, "
];

const locale_text_data = [
  {
    // Empty input
    "locale": "en-US",
    "input": "",
  },

  {
    "locale": "en-US",
    "input": "The caÌ‚t, in the hat. There's a dogÌˆ in the yard?",
  },
  {
    "locale": "ja-JP",
    "input": "æ–‡å­—ã«åˆ†è§£ã—ã¾ã—ã‚‡ã†ã€‚å˜èªã«ã‚‚ã€‚ã‚ã‚ã€æ–‡ã«ã‚‚ã€‚"
  },
  {
    "locale": "fr",
    "input": "C'est ainsi qu'on dÃ©compose les personnages. Les mots aussi. Oh, et les phrases aussi."
  },
  {
    "locale": "as",
    "input": "à¦à¦‡à¦Ÿà§‹à§±à§‡à¦‡ à¦¹à§ˆà¦›à§‡ à¦šà§°à¦¿à¦¤à§à§°à¦¤ à¦­à¦¾à¦™à¦¿ à¦¯à§‹à§±à¦¾à§° à¦‰à¦ªà¦¾à¦¯à¦¼à¥¤ à¦²à¦—à¦¤à§‡ à¦¶à¦¬à§à¦¦à¥¤ à¦…â€™, à¦†à§°à§ à¦¬à¦¾à¦•à§à¦¯à¦¬à§‹à§°à§‹à¥¤"
  },
  {
    "locale": "zh-Hans",
    "input": "åˆ†è§£æˆå­—ç¬¦ã€‚è¿˜æœ‰å•è¯ã€‚å“¦ï¼Œè¿˜æœ‰å¥å­ã€‚"
  },
  {
    "locale": "zh-Hant",
    "input": "åˆ†è§£æˆå­—å…ƒã€‚é‚„æœ‰æ–‡å­—ã€‚å“¦ï¼Œé‚„æœ‰å¥å­ã€‚"
  },
  {
    "locale": "my",
    "input": "á€¤á€á€Šá€ºá€™á€¾á€¬ á€‡á€¬á€á€ºá€€á€±á€¬á€„á€ºá€™á€»á€¬á€¸á€¡á€–á€¼á€…á€ºá€á€­á€¯á€· á€–á€±á€¬á€€á€ºá€‘á€½á€€á€ºá€›á€”á€º á€”á€Šá€ºá€¸á€œá€™á€ºá€¸á€–á€¼á€…á€ºá€á€Šá€ºá‹ á€…á€€á€¬á€¸á€œá€Šá€ºá€¸ á€•á€«á€á€šá€ºá‹ á€á€¼á€±á€¬á€º á€…á€¬á€€á€¼á€±á€¬á€„á€ºá€¸á€á€½á€±á€œá€Šá€ºá€¸ á€•á€«á€•á€«á€á€šá€ºá‹"
  },
  {
    "locale": "ff-Adlm",
    "input": "ğ¤Šğ¤­ğ¤´ğ¤¢ğ¥„ğ¤³ğ¤µ ğ¤±ğ¤¢ğ¤´ğ¤¤ğ¤®ğ¤ªğ¤¢ ğ¤³ğ¤«ğ¤²ğ¤«ğ¤². ğ¤–ğ¤¢ğ¤³ğ¥†ğ¤«ğ¤ªğ¤«ğ¤² ğ¤«ğ¤¯ğ¤«ğ¤² ğ¤¸ğ¤®ğ¥…ğ¤¤ğ¤­ğ¥…  ğ¤¸ğ¤­ğ¤§ğ¤­â¹ ğ¤«ğ¤²ğ¤¢ ğ¤¯ğ¤«ğ¤². ğ¤ğ¤£ğ¤«ğ¤²ğ¤§ğ¤¢ğ¤´ ğ¤¼ğ¤µğ¤²â¹ ğ¤­ğ¤±ğ¤ªğ¤¢ğ¤¼ğ¤¢ ğ¤±ğ¤®ğ¥…â¹ ğ¤£ğ¤«ğ¥…ğ¤°ğ¤µğ¤²ğ¤®ğ¥… ğ¤¬ğ¤®ğ¤±â¹ ğ¤®ğ¤²."
  },
  {
    "locale": "ko",
    "input": "ì—¬ê¸°ì„œ ì ê¹ ì‰¬ì. ì™œ?"
  },
  {
    "locale": "ar",
    "input": "Ù†Ø­Ù† Ù†ÙƒØ³Ø± Ù‡Ù†Ø§. Ù„Ù…Ø§Ø°Ø§ØŸ"
  }
];

function generateAll() {

  let test_obj = {
    'test_type': test_type,
    'description': 'Segmenter test data generated by NodeJS',
    'platformVersion': process.version,
    'icuVersion': process.versions.icu,
    'cldrVersion': process.versions.cldr
  };

  let test_cases = [];

  let verify_obj = {
    'test_type': test_type,
    'description': 'segmenter expected resuls generated by NodeJS',
    'platformVersion': process.version,
    'icuVersion': process.versions.icu,
    'cldrVersion': process.versions.cldr
  }
  let verify_cases = [];

  let label_num = 0;

  const expected_count = locale_text_data.length * granularity.length;

  console.log("Generating up to ", expected_count, " segmenter tests for ",
              process.versions.icu);

  for (const locale_data of locale_text_data) {

    const locale = locale_data['locale'];
    for (const segmentation_type of granularity) {

      // Create format object with these options
      let all_options = {};
      if (segmentation_type == 'line') {
        // To get line data, even though not supported in ECMA Intl
        all_options['granularity'] = 'word';
      } else {
        all_options['granularity'] = segmentation_type;
      }

      let segmenter;
      try {
        segmenter = new Intl.Segmenter(locale, all_options);
      } catch (error) {
        console.log(error, ' with locale ',
                    locale, ' and options: ', all_options);
        continue;
      }

      const input = locale_data['input'];
      let result = [];
      try {
        const iterator = segmenter.segment(input)[Symbol.iterator]();
        let seg_item = iterator.next();
        while (! seg_item.done) {
          result.push(seg_item.value.segment);
          seg_item = iterator.next();
        }
      } catch (error) {
        console.log('SEGMENTER FAIL! ', error);
      }
      const label_string = String(label_num);

      if (segmentation_type == 'grapheme') {
        all_options['granularity'] = 'grapheme_cluster';
      }
      let test_list;
      let test_case = {
        "locale": locale,
        "options": all_options,
        "input": input
      };
      gen_hash.generate_hash_for_test(test_case);
      test_case['label'] = label_string;

      if (debug) {
        console.log("TEST CASE :", '<', test_case);
      }
      if (segmentation_type == 'line') {
        // To get line data, even though not supported in ECMAIntl
        all_options['granularity'] = 'line';
        // Expected data should not yield spaces or punctuation as separate results.
        let line_result = [];
        let previous = '';
        let last = result.length;
        let index = last - 1;
        let new_result = [];
        while (index > 0) {
          if (line_values_to_merge_with_previous.indexOf(result[index]) >= 0) {
            result[index-1] += result[index];
          } else {
            new_result.unshift(result[index]);
          }
          index -= 1;
        }
        if (result.length > 0) {
          new_result.unshift(result[0]);
        }
        result = new_result;
      }

      test_cases.push(test_case);

      // Generate what we get.
      try{
        verify_cases.push({'label': label_string,
                           'verify': result});
      } catch (error) {
        console.log('!!! error ', error, ' in label ', label_num,
                    ' for options ', options);
      }
      label_num ++;
    };
  }

  if (debug) {
    console.log('Number of segmenter tests generated for ',
                process.versions.icu, ': ', label_num);
    console.log(' RUN LIMIT = ', run_limit);
  }

  test_obj['tests'] = common_fns.sample_tests(test_cases, run_limit);
  try {
    fs.writeFileSync('segmenter_test.json', JSON.stringify(test_obj, null));
    // file written successfully
  } catch (err) {
    console.error(err);
  }

  verify_obj['verifications'] = common_fns.sample_tests(verify_cases, run_limit);
  try {
    fs.writeFileSync('segmenter_verify.json', JSON.stringify(verify_obj, null));
    // file written successfully
  } catch (err) {
    console.error(err);
  }
}

if (debug) {
  console.log('SEGMENTER argv: ', process.argv);
}

let run_limit = -1;
if (process.argv.length >= 4) {
  if (process.argv[2] == '-run_limit') {
    run_limit = Number(process.argv[3]);
  }
}

/* Call the generator */
generateAll(run_limit);
